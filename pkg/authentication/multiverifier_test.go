package authentication

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewMultiHashVerifier(t *testing.T) {
	verifier := NewMultiHashVerifier()
	assert.NotNil(t, verifier)
	assert.NotNil(t, verifier.unixCrypt)
	assert.NotNil(t, verifier.argon2id)
}

func TestMultiHashVerifier_VerifyPassword_UnixCrypt(t *testing.T) {
	verifier := NewMultiHashVerifier()

	// Use hash from existing unixcrypt tests
	// Password: "testpassword123", Hash: "tek4edTZE898g" (salt: "te")
	password := "testpassword123"
	hash := "tek4edTZE898g"

	err := verifier.VerifyPassword(password, hash)
	assert.NoError(t, err)

	// Test with wrong password
	err = verifier.VerifyPassword("wrongpass", hash)
	assert.Error(t, err)
}

func TestMultiHashVerifier_VerifyPassword_Argon2id(t *testing.T) {
	verifier := NewMultiHashVerifier()
	password := "testpassword123"

	// Generate an Argon2id hash for testing
	hash, err := generateArgon2idHash(password, 65536, 3, 4, 32)
	assert.NoError(t, err)

	// Should verify successfully
	err = verifier.VerifyPassword(password, hash)
	assert.NoError(t, err)

	// Should fail with wrong password
	err = verifier.VerifyPassword("wrongpassword", hash)
	assert.Error(t, err)
}

func TestMultiHashVerifier_VerifyPassword_HashDetection(t *testing.T) {
	verifier := NewMultiHashVerifier()

	testCases := []struct {
		name        string
		hash        string
		shouldError bool
		errorMsg    string
	}{
		{
			name:        "unix crypt - valid format",
			hash:        "te8sTJwYfz2Qo",
			shouldError: false,
		},
		{
			name:        "argon2id - valid format",
			hash:        "$argon2id$v=19$m=65536,t=3,p=4$c2FsdA$aGFzaA",
			shouldError: false,
		},
		{
			name:        "empty hash",
			hash:        "",
			shouldError: true,
			errorMsg:    "empty hash",
		},
		{
			name:        "unsupported hash - bcrypt",
			hash:        "$2a$10$N9qo8uLOickgx2ZMRZoMye",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - too long for crypt",
			hash:        "this_is_too_long_for_unix_crypt",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - too short",
			hash:        "short",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - crypt with dollar",
			hash:        "te8sTJw$fz2Qo",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - argon2",
			hash:        "$argon2$v=19$m=65536,t=3,p=4$c2FsdA$aGFzaA",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - argon2i",
			hash:        "$argon2i$v=19$m=65536,t=3,p=4$c2FsdA$aGFzaA",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
		{
			name:        "unsupported hash - argon2d",
			hash:        "$argon2d$v=19$m=65536,t=3,p=4$c2FsdA$aGFzaA",
			shouldError: true,
			errorMsg:    "unsupported hash format",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := verifier.VerifyPassword("testpass", tc.hash)
			if tc.shouldError {
				assert.Error(t, err)
				if tc.errorMsg != "" {
					assert.Contains(t, err.Error(), tc.errorMsg)
				}
			} else {
				// Note: These tests focus on detection logic, not actual password verification
				// The hash formats are valid, but we're not testing actual password matching
				// since that's covered in individual verifier tests
			}
		})
	}
}

func TestMultiHashVerifier_VerifyPassword_BackwardCompatibility(t *testing.T) {
	verifier := NewMultiHashVerifier()
	uc := NewUnixCrypt()

	// Test that MultiHashVerifier works with hashes generated by UnixCrypt
	testPasswords := []string{"test", "pass", "secret123"}

	for _, password := range testPasswords {
		t.Run("unix_crypt_"+password, func(t *testing.T) {
			// Generate hash using original UnixCrypt
			hash, err := uc.Hash(password)
			assert.NoError(t, err)

			// Verify with MultiHashVerifier (should auto-detect Unix crypt)
			err = verifier.VerifyPassword(password, hash)
			assert.NoError(t, err)

			// Verify wrong password fails
			err = verifier.VerifyPassword("wrongpass", hash)
			assert.Error(t, err)
		})
	}
}

func TestMultiHashVerifier_VerifyPassword_MixedHashes(t *testing.T) {
	verifier := NewMultiHashVerifier()

	// Create test data with both hash types
	testData := []struct {
		name     string
		password string
		hashType string
	}{
		{"unix_crypt_user", "password123", "crypt"},
		{"argon2id_user", "password456", "argon2id"},
		{"another_crypt", "secret", "crypt"},
		{"another_argon2id", "topsecret", "argon2id"},
	}

	// Generate hashes and verify them
	for _, td := range testData {
		t.Run(td.name, func(t *testing.T) {
			var hash string
			var err error

			if td.hashType == "crypt" {
				// Use UnixCrypt to generate a hash for testing
				uc := NewUnixCrypt()
				hash, err = uc.Hash(td.password)
				assert.NoError(t, err)
			} else {
				// Generate Argon2id hash
				hash, err = generateArgon2idHash(td.password, 65536, 3, 4, 32)
				assert.NoError(t, err)
			}

			// Verify the multi-verifier can handle both types
			err = verifier.VerifyPassword(td.password, hash)
			assert.NoError(t, err)

			// Verify wrong password fails
			err = verifier.VerifyPassword("wrongpassword", hash)
			assert.Error(t, err)
		})
	}
}

func TestMultiHashVerifier_ConstantTimeAttackResistance(t *testing.T) {
	verifier := NewMultiHashVerifier()

	// This is a basic test to ensure the verifier still calls verification
	// even for unknown hash formats (important for timing attack resistance)
	unknownHashes := []string{
		"unsupported_format",
		"$unknown$hash$format",
		"tooshortforcrypt",
	}

	for _, hash := range unknownHashes {
		err := verifier.VerifyPassword("password", hash)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "unsupported hash format")
	}
}

func BenchmarkMultiHashVerifier_UnixCrypt(b *testing.B) {
	verifier := NewMultiHashVerifier()
	password := "testpass"
	hash := "te8sTJwYfz2Qo"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = verifier.VerifyPassword(password, hash)
	}
}

func BenchmarkMultiHashVerifier_Argon2id(b *testing.B) {
	verifier := NewMultiHashVerifier()
	password := "testpass"
	hash, err := generateArgon2idHash(password, 32768, 2, 2, 32) // Use lighter parameters for benchmark
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = verifier.VerifyPassword(password, hash)
	}
}